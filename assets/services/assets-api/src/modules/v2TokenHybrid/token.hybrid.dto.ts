import { ApiProperty } from '@nestjs/swagger';
import {
  IsOptional,
  ValidateNested,
  IsPositive,
  IsNumber,
} from 'class-validator';

import { keys as UserKeys, UserExample } from 'src/types/user';
import {
  keys as TokenKeys,
  TokenExtendedExample,
  Token,
  TokenExample,
  TOKEN_SYMBOL_MAX_LENGTH,
  DEFAULT_TOKEN_NAME,
  DEFAULT_TOKEN_SYMBOL,
  ASSET_CLASS_MAX_LENGTH,
  DEFAULT_CLASS_NAME,
  TokenInputDataExample,
} from 'src/types/token';
import { keys as NetworkKeys, NetworkExample } from 'src/types/network';
import { keys as ActionKeys } from 'src/types/workflow/workflowInstances';
import { TokenState } from 'src/types/states';
import { getEnumValues } from 'src/utils/enumUtils';
import { InputDataExample } from 'src/types';
import { CertificateType, SmartContract } from 'src/types/smartContract';
import { ENTITY_DESCRIPTION_MAX_LENGTH } from 'src/types/entity';
import { keys as TxKeys } from 'src/types/transaction';
import { TransactionExample } from 'src/types/transaction';
import {
  ActionExample,
  Action,
} from 'src/types/workflow/workflowInstances/action';
import { InitialSupply, InitialSupplyExample } from 'src/types/supply';

export class CreateHybridTokenBodyInput {
  @ApiProperty({
    description: `Must be a valid hybrid token standard: ${SmartContract.ERC1400_HOLDABLE_CERTIFICATE}`,
    example: SmartContract.ERC1400_HOLDABLE_CERTIFICATE,
  })
  @IsOptional()
  tokenStandard: SmartContract;

  @ApiProperty({
    description: 'Token name',
    example: DEFAULT_TOKEN_NAME,
  })
  @IsOptional()
  name: string;

  @ApiProperty({
    description: `Must be a less than ${TOKEN_SYMBOL_MAX_LENGTH} characters long`,
    example: DEFAULT_TOKEN_SYMBOL,
  })
  @IsOptional()
  symbol: string;

  @ApiProperty({
    description: `Each class must be a less than ${ASSET_CLASS_MAX_LENGTH} characters long`,
    example: [
      DEFAULT_CLASS_NAME.concat('1'),
      DEFAULT_CLASS_NAME.concat('2'),
      DEFAULT_CLASS_NAME.concat('3'),
    ],
  })
  @IsOptional()
  classes: Array<string>;

  @ApiProperty({
    description:
      'ID of the KYC template investors that will be applied to investors (leave undefined if no KYC will be requested from investors)',
    example: 'b32f6346-53b5-4cc6-a3f3-0012ed5e67a3',
  })
  @IsOptional()
  kycTemplateId: string;

  @ApiProperty({
    description:
      '[DEPRECATED - Replaced by certificateType] If set to true, no token action (mint, transfer, burn) can be performed without certificates generated by Codefi API (security).',
    example: true,
  })
  @IsOptional()
  certificateActivated: boolean;

  @ApiProperty({
    description: `Type of certificate validation. Shall be chosen amongst ${CertificateType.NONE}, ${CertificateType.NONCE} and ${CertificateType.SALT}`,
    example: true,
  })
  @IsOptional()
  certificateType: CertificateType;

  @ApiProperty({
    description:
      'If set to true, tokens from default partitions can be transferred without restriction, e.g. with unregulated ERC20 transfers',
    example: true,
  })
  @IsOptional()
  unregulatedERC20transfersActivated: boolean;

  @ApiProperty({
    description:
      'Address of wallet to use to create the token (only required if not the default wallet)',
    example: UserExample[UserKeys.DEFAULT_WALLET],
  })
  @IsOptional()
  wallet: string;

  @ApiProperty({
    description: 'ID of the chain/network where the token shall be created',
    example: NetworkExample[NetworkKeys.CHAIN_ID],
  })
  @IsOptional()
  chainId: string; // TO BE DEPRECATED (replaced by 'networkKey')

  @ApiProperty({
    description: 'Key of the chain/network where the token shall be created',
    example: NetworkExample[NetworkKeys.KEY],
  })
  @IsOptional()
  networkKey: string;

  @ApiProperty({
    description: 'Picture of the asset',
    example: TokenExample[TokenKeys.PICTURE],
  })
  @IsOptional()
  picture: string;

  @ApiProperty({
    description: `Must be a less than ${ENTITY_DESCRIPTION_MAX_LENGTH} characters long`,
    example: TokenExample[TokenKeys.DESCRIPTION],
  })
  @IsOptional()
  description: string;

  @ApiProperty({
    description: 'Object containing bank account infos',
    example: TokenExample[TokenKeys.BANK_ACCOUNT],
  })
  @IsOptional()
  bankDepositDetail: any;

  @ApiProperty({
    description:
      'Object to store any additional data (potentially use case related data)',
    example: TokenInputDataExample,
  })
  @IsOptional()
  data: any;

  @ApiProperty({
    description:
      'Must be a valid notary ID. Used to attach a notary to the token, thus allowing him to access all token data (investors, balances, etc.)',
    example: UserExample[UserKeys.USER_ID],
  })
  @IsOptional()
  notaryId: any;

  @ApiProperty({
    description:
      'Send notification flag (if true user will be notified by mail)',
  })
  @IsOptional()
  sendNotification: boolean;

  @ApiProperty({
    description:
      'Must be valid smart contract address, already deployed on the specified network, and where the issuer is already a minter',
    example: TokenExample[TokenKeys.DEFAULT_DEPLOYMENT],
  })
  @IsOptional()
  tokenAddress: any;

  @ApiProperty({
    description:
      '[OPTIONAL] Address of "custom" extension contract, the token contract will be linked to. If undefined, token contract will be linked to "generic" extension contract by default.',
    example: '0x0089d53F703f7E0843953D48133f74cE247184c2',
  })
  @IsOptional()
  customExtensionAddress: string;

  @ApiProperty({
    description:
      '[OPTIONAL] Address, the token contract ownership shall be transferred to. If undefined, token contract will not be transferred (but this can still be done afterwards).',
    example: '0x0089d53F703f7E0843953D48133f74cE247184c2',
  })
  @IsOptional()
  initialOwnerAddress: string;

  @ApiProperty({
    description:
      "If set 'true', Issuer is not required to approve secondary trade orders",
    example: true,
  })
  @IsOptional()
  bypassSecondaryTradeIssuerApproval: boolean;

  @ApiProperty({
    description:
      'Array of initial supplies to be minted right after asset creation',
    example: [InitialSupplyExample],
  })
  @IsOptional()
  initialSupplies: Array<InitialSupply>;
}

export class RetrieveHybridTokenQueryInput {
  @ApiProperty({
    description:
      "Asset class of token, that shall be retrieved ('undefined' if all asset classes shall be retrieved)",
    example: 'classa',
  })
  @IsOptional()
  assetClass: string;

  @ApiProperty({
    description:
      "If set 'true', user's vehicles, linked to the specified token, are retrieved as well",
    example: true,
  })
  @IsOptional()
  withVehicles: boolean;

  @ApiProperty({
    description:
      "If set 'true', user's balances for the specified token are retrieved as well",
    example: true,
  })
  @IsOptional()
  withBalances: boolean;

  @ApiProperty({
    description:
      "If set 'true', user's ETH balance, on the network where the specified token is deployed, is retrieved as well",
    example: true,
  })
  @IsOptional()
  withEthBalance: boolean;

  @IsOptional()
  withCycles: boolean;

  @ApiProperty({
    description:
      "If set 'true', asset Meta data of the token is retrieved as well",
    example: true,
  })
  @IsOptional()
  withAssetData: boolean;
}

export class RetrieveHybridTokenParamInput {
  @ApiProperty({
    description: 'ID of token to retrieve',
    example: TokenExample[TokenKeys.TOKEN_ID],
  })
  tokenId: string;
}

export class RetrieveHybridTokenSymbolParamInput {
  @ApiProperty({
    description: 'Symbol of token to retrieve',
    example: TokenExample[TokenKeys.TOKEN_ID],
  })
  symbol: string;
}

export class RetrieveHybridTokenOutput {
  @ApiProperty({
    description: 'Retrieved hybrid token',
    example: TokenExtendedExample,
  })
  @ValidateNested()
  token: Token;

  @ApiProperty({
    description: 'Response message',
    example: `Hybrid token ${
      TokenExample[TokenKeys.TOKEN_ID]
    } retrieved successfully`,
  })
  message: string;
}

export class UpdateHybridTokenParamInput {
  @ApiProperty({
    description: 'ID of token to update',
    example: TokenExample[TokenKeys.TOKEN_ID],
  })
  tokenId: string;
}

export class UpdateHybridTokenBodyInput {
  @ApiProperty({
    description: 'Token parameters to update',
    example: {
      [TokenKeys.PICTURE]: TokenExample[TokenKeys.PICTURE],
      [TokenKeys.DESCRIPTION]: TokenExample[TokenKeys.DESCRIPTION],
      [TokenKeys.BANK_ACCOUNT]: TokenExample[TokenKeys.BANK_ACCOUNT],
      [TokenKeys.DATA]: {
        key1: 'value1',
        key2: 'value2',
        key3: 'value3',
        keyn: 'valuen',
      },
    },
  })
  updatedParameters: any;
}

export class UpdateHybridTokenOutput {
  @ApiProperty({
    description: 'Updated hybrid token',
    example: TokenExample,
  })
  @ValidateNested()
  token: Token;

  @ApiProperty({
    description: 'Response message',
    example: `Hybrid token ${
      TokenExample[TokenKeys.TOKEN_ID]
    } updated successfully`,
  })
  message: string;
}

export class MintHybridTokenParamInput {
  @ApiProperty({
    description: 'ID of token, where a minting transaction shall be executed',
    example: TokenExample[TokenKeys.TOKEN_ID],
  })
  tokenId: string;
}

export class MintHybridTokenBodyInput {
  @ApiProperty({
    description:
      '[OPTIONAL] Idempotency key (shall be unique and generated on client side), used to ensure object is not created twice',
    example: ActionExample[ActionKeys.IDEMPOTENCY_KEY],
  })
  @IsOptional()
  idempotencyKey: string;

  @ApiProperty({
    description: 'ID of the user, tokens shall be minted for',
    example: UserExample[UserKeys.USER_ID],
  })
  recipientId: string;

  @ApiProperty({
    description: `State of the token to mint, chosen amongst ${getEnumValues(
      TokenState,
    )}`,
    example: TokenState.LOCKED,
  })
  state: TokenState;

  @ApiProperty({
    description: `Class of the tokens to mint (shall be less than ${ASSET_CLASS_MAX_LENGTH} characters long)`,
    example: ActionExample[ActionKeys.ASSET_CLASS],
  })
  class: string;

  @ApiProperty({
    description: 'Quantity of tokens to mint',
    example: ActionExample[ActionKeys.QUANTITY],
  })
  quantity: number;

  @ApiProperty({
    description:
      'Optional parameter to force the price of the operation. If not defined, price will be set automatically, based on NAV value (recommended).',
    example: ActionExample[ActionKeys.PRICE],
  })
  @IsOptional()
  forcePrice: number;

  @ApiProperty({
    description:
      'Object to store any additional data (potentially use case related data)',
    example: InputDataExample,
  })
  @IsOptional()
  data: any;

  @ApiProperty({
    description:
      'Send notification flag (if true user will be notified by mail)',
  })
  @IsOptional()
  sendNotification: boolean;
}

export class TranferHybridTokenParamInput {
  @ApiProperty({
    description: 'ID of token, where a transfer transaction shall be executed',
    example: TokenExample[TokenKeys.TOKEN_ID],
  })
  tokenId: string;
}

export class TransferHybridTokenBodyInput {
  @ApiProperty({
    description:
      '[OPTIONAL] Idempotency key (shall be unique and generated on client side), used to ensure object is not created twice',
    example: ActionExample[ActionKeys.IDEMPOTENCY_KEY],
  })
  @IsOptional()
  idempotencyKey: string;

  @ApiProperty({
    description: 'ID of the user, tokens shall be transferred to',
    example: UserExample[UserKeys.USER_ID],
  })
  recipientId: string;

  @ApiProperty({
    description: `State of the token to transfer, chosen amongst ${getEnumValues(
      TokenState,
    )}`,
    example: TokenState.LOCKED,
  })
  state: TokenState;

  @ApiProperty({
    description: 'Class of the tokens to transfer',
    example: ActionExample[ActionKeys.ASSET_CLASS],
  })
  class: string;

  @ApiProperty({
    description: 'Quantity of tokens to transfer',
    example: ActionExample[ActionKeys.QUANTITY],
  })
  quantity: number;

  @ApiProperty({
    description:
      'Optional parameter to force the price of the operation. If not defined, price will be set automatically, based on NAV value (recommended).',
    example: ActionExample[ActionKeys.PRICE],
  })
  @IsOptional()
  @IsPositive()
  @IsNumber()
  forcePrice: number;

  @ApiProperty({
    description:
      'Object to store any additional data (potentially use case related data)',
    example: InputDataExample,
  })
  @IsOptional()
  data: any;
}

export class BurnHybridTokenParamInput {
  @ApiProperty({
    description: 'ID of token, where a burn transaction shall be executed',
    example: TokenExample[TokenKeys.TOKEN_ID],
  })
  tokenId: string;
}

export class BurnHybridTokenBodyInput {
  @ApiProperty({
    description:
      '[OPTIONAL] Idempotency key (shall be unique and generated on client side), used to ensure object is not created twice',
    example: ActionExample[ActionKeys.IDEMPOTENCY_KEY],
  })
  @IsOptional()
  idempotencyKey: string;

  @ApiProperty({
    description: `State of the token to burn, chosen amongst ${getEnumValues(
      TokenState,
    )}`,
    example: TokenState.LOCKED,
  })
  state: TokenState;

  @ApiProperty({
    description: 'Class of the tokens to burn',
    example: ActionExample[ActionKeys.ASSET_CLASS],
  })
  class: string;

  @ApiProperty({
    description: 'Quantity of tokens to burn',
    example: ActionExample[ActionKeys.QUANTITY],
  })
  quantity: number;

  @ApiProperty({
    description:
      'Optional parameter to force the price of the operation. If not defined, price will be set automatically, based on NAV value (recommended).',
    example: ActionExample[ActionKeys.PRICE],
  })
  @IsOptional()
  forcePrice: number;

  @ApiProperty({
    description:
      'Object to store any additional data (potentially use case related data)',
    example: InputDataExample,
  })
  @IsOptional()
  data: any;
}

export class ForceTranferHybridTokenParamInput {
  @ApiProperty({
    description: 'ID of token, where a transfer transaction shall be executed',
    example: TokenExample[TokenKeys.TOKEN_ID],
  })
  tokenId: string;
}

export class ForceTransferHybridTokenBodyInput {
  @ApiProperty({
    description:
      '[OPTIONAL] Idempotency key (shall be unique and generated on client side), used to ensure object is not created twice',
    example: ActionExample[ActionKeys.IDEMPOTENCY_KEY],
  })
  @IsOptional()
  idempotencyKey: string;

  @ApiProperty({
    description: 'ID of the user, whom tokens shall be transferred from',
    example: UserExample[UserKeys.USER_ID],
  })
  investorId: string;

  @ApiProperty({
    description: 'ID of the user, whom tokens shall be transferred to',
    example: UserExample[UserKeys.USER_ID],
  })
  recipientId: string;

  @ApiProperty({
    description: `State of the token to transfer, chosen amongst ${getEnumValues(
      TokenState,
    )}`,
    example: TokenState.LOCKED,
  })
  state: TokenState;

  @ApiProperty({
    description: 'Class of the tokens to transfer',
    example: ActionExample[ActionKeys.ASSET_CLASS],
  })
  class: string;

  @ApiProperty({
    description: 'Quantity of tokens to transfer',
    example: ActionExample[ActionKeys.QUANTITY],
  })
  quantity: number;

  @ApiProperty({
    description:
      'Optional parameter to force the price of the operation. If not defined, price will be set automatically, based on NAV value (recommended).',
    example: ActionExample[ActionKeys.PRICE],
  })
  @IsOptional()
  forcePrice: number;

  @ApiProperty({
    description:
      'Object to store any additional data (potentially use case related data)',
    example: InputDataExample,
  })
  @IsOptional()
  data: any;

  @ApiProperty({
    description:
      'Send notification flag (if true user will be notified by mail)',
  })
  @IsOptional()
  sendNotification: boolean;
}

export class ForceBurnHybridTokenParamInput {
  @ApiProperty({
    description: 'ID of token, where a burn transaction shall be executed',
    example: TokenExample[TokenKeys.TOKEN_ID],
  })
  tokenId: string;
}

export class ForceBurnHybridTokenBodyInput {
  @ApiProperty({
    description:
      '[OPTIONAL] Idempotency key (shall be unique and generated on client side), used to ensure object is not created twice',
    example: ActionExample[ActionKeys.IDEMPOTENCY_KEY],
  })
  @IsOptional()
  idempotencyKey: string;

  @ApiProperty({
    description: 'ID of the user, whom tokens shall be burned from',
    example: UserExample[UserKeys.USER_ID],
  })
  investorId: string;

  @ApiProperty({
    description: `State of the token to burn, chosen amongst ${getEnumValues(
      TokenState,
    )}`,
    example: TokenState.LOCKED,
  })
  state: TokenState;

  @ApiProperty({
    description: 'Class of the tokens to burn',
    example: ActionExample[ActionKeys.ASSET_CLASS],
  })
  class: string;

  @ApiProperty({
    description: 'Quantity of tokens to burn',
    example: ActionExample[ActionKeys.QUANTITY],
  })
  quantity: number;

  @ApiProperty({
    description:
      'Optional parameter to force the price of the operation. If not defined, price will be set automatically, based on NAV value (recommended).',
    example: ActionExample[ActionKeys.PRICE],
  })
  @IsOptional()
  forcePrice: number;

  @ApiProperty({
    description:
      'Object to store any additional data (potentially use case related data)',
    example: InputDataExample,
  })
  @IsOptional()
  data: any;

  @ApiProperty({
    description:
      'Send notification flag (if true user will be notified by mail)',
  })
  @IsOptional()
  sendNotification: boolean;
}

export class UpdateStateHybridTokenParamInput {
  @ApiProperty({
    description:
      'ID of token, where an updateState transaction shall be executed',
    example: TokenExample[TokenKeys.TOKEN_ID],
  })
  tokenId: string;
}

export class UpdateStateHybridTokenBodyInput {
  @ApiProperty({
    description:
      '[OPTIONAL] Idempotency key (shall be unique and generated on client side), used to ensure object is not created twice',
    example: ActionExample[ActionKeys.IDEMPOTENCY_KEY],
  })
  @IsOptional()
  idempotencyKey: string;

  @ApiProperty({
    description: `State of the token to update, chosen amongst ${getEnumValues(
      TokenState,
    )}`,
    example: TokenState.LOCKED,
  })
  state: TokenState;

  @ApiProperty({
    description: 'Class of the tokens to update',
    example: ActionExample[ActionKeys.ASSET_CLASS],
  })
  class: string;

  @ApiProperty({
    description: `Destination state of the token to update, chosen amongst ${getEnumValues(
      TokenState,
    )}`,
    example: TokenState.ISSUED,
  })
  destinationState: TokenState;

  @ApiProperty({
    description: 'Quantity of tokens to update',
    example: ActionExample[ActionKeys.QUANTITY],
  })
  quantity: number;

  @ApiProperty({
    description:
      'Optional parameter to force the price of the operation. If not defined, price will be set automatically, based on NAV value (recommended).',
    example: ActionExample[ActionKeys.PRICE],
  })
  @IsOptional()
  forcePrice: number;

  @ApiProperty({
    description:
      'Object to store any additional data (potentially use case related data)',
    example: InputDataExample,
  })
  @IsOptional()
  data: any;

  @ApiProperty({
    description: 'Remarks in the email notification',
    example: JSON.stringify([
      'I would like to retire these credit, to offset 1,000 tonnes of carbon produced by the benificiary oin 2021.',
    ]),
  })
  @IsOptional()
  emailRemarks: string;

  @ApiProperty({
    description:
      'Send notification flag (if true user will be notified by mail)',
  })
  @IsOptional()
  sendNotification: boolean;
}

export class ForceUpdateStateHybridTokenParamInput {
  @ApiProperty({
    description:
      'ID of token, where an updateState transaction shall be executed',
    example: TokenExample[TokenKeys.TOKEN_ID],
  })
  tokenId: string;
}

export class ForceUpdateStateHybridTokenBodyInput {
  @ApiProperty({
    description:
      '[OPTIONAL] Idempotency key (shall be unique and generated on client side), used to ensure object is not created twice',
    example: ActionExample[ActionKeys.IDEMPOTENCY_KEY],
  })
  @IsOptional()
  idempotencyKey: string;

  @ApiProperty({
    description: "ID of the user, tokens' state shall be updated from",
    example: UserExample[UserKeys.USER_ID],
  })
  investorId: string;

  @ApiProperty({
    description: `State of the token to update, chosen amongst ${getEnumValues(
      TokenState,
    )}`,
    example: TokenState.LOCKED,
  })
  state: TokenState;

  @ApiProperty({
    description: 'Class of the tokens to update',
    example: ActionExample[ActionKeys.ASSET_CLASS],
  })
  class: string;

  @ApiProperty({
    description: `Destination state of the token to update, chosen amongst ${getEnumValues(
      TokenState,
    )}`,
    example: TokenState.ISSUED,
  })
  destinationState: TokenState;

  @ApiProperty({
    description: 'Quantity of tokens to update',
    example: ActionExample[ActionKeys.QUANTITY],
  })
  quantity: number;

  @ApiProperty({
    description:
      'Optional parameter to force the price of the operation. If not defined, price will be set automatically, based on NAV value (recommended).',
    example: ActionExample[ActionKeys.PRICE],
  })
  @IsOptional()
  forcePrice: number;

  @ApiProperty({
    description:
      'Object to store any additional data (potentially use case related data)',
    example: InputDataExample,
  })
  @IsOptional()
  data: any;
}

export class UpdateClassHybridTokenParamInput {
  @ApiProperty({
    description:
      'ID of token, where an updateClass transaction shall be executed',
    example: TokenExample[TokenKeys.TOKEN_ID],
  })
  tokenId: string;
}

export class UpdateClassHybridTokenBodyInput {
  @ApiProperty({
    description:
      '[OPTIONAL] Idempotency key (shall be unique and generated on client side), used to ensure object is not created twice',
    example: ActionExample[ActionKeys.IDEMPOTENCY_KEY],
  })
  @IsOptional()
  idempotencyKey: string;

  @ApiProperty({
    description: "ID of the user, tokens' class shall be updated from",
    example: UserExample[UserKeys.USER_ID],
  })
  investorId: string;

  @ApiProperty({
    description: `State of the token to update, chosen amongst ${getEnumValues(
      TokenState,
    )}`,
    example: TokenState.LOCKED,
  })
  state: TokenState;

  @ApiProperty({
    description: 'Class of the tokens to update',
    example: ActionExample[ActionKeys.ASSET_CLASS],
  })
  class: string;

  @ApiProperty({
    description: `Destination class of the token to update (shall be less than ${ASSET_CLASS_MAX_LENGTH} characters long)`,
    example: ActionExample[ActionKeys.ASSET_CLASS].concat('2'),
  })
  destinationClass: string;

  @ApiProperty({
    description: 'Quantity of tokens to update',
    example: ActionExample[ActionKeys.QUANTITY],
  })
  quantity: number;

  @ApiProperty({
    description:
      'Optional parameter to force the price of the operation. If not defined, price will be set automatically, based on NAV value (recommended).',
    example: ActionExample[ActionKeys.PRICE],
  })
  @IsOptional()
  forcePrice: number;

  @ApiProperty({
    description:
      'Object to store any additional data (potentially use case related data)',
    example: InputDataExample,
  })
  @IsOptional()
  data: any;
}

export class HoldHybridTokenParamInput {
  @ApiProperty({
    description: 'ID of token, where a hold transaction shall be executed',
    example: TokenExample[TokenKeys.TOKEN_ID],
  })
  tokenId: string;
}

export class HoldHybridTokenBodyInput {
  @ApiProperty({
    description:
      '[OPTIONAL] Idempotency key (shall be unique and generated on client side), used to ensure object is not created twice',
    example: ActionExample[ActionKeys.IDEMPOTENCY_KEY],
  })
  @IsOptional()
  idempotencyKey: string;

  @ApiProperty({
    description: 'ID of the user, who shall be added as recipient of the hold',
    example: UserExample[UserKeys.USER_ID],
  })
  recipientId: string;

  @ApiProperty({
    description: `State of the token to hold, chosen amongst ${getEnumValues(
      TokenState,
    )}`,
    example: TokenState.LOCKED,
  })
  state: TokenState;

  @ApiProperty({
    description: 'Class of the tokens to hold',
    example: ActionExample[ActionKeys.ASSET_CLASS],
  })
  class: string;

  @ApiProperty({
    description: 'Quantity of tokens to hold',
    example: ActionExample[ActionKeys.QUANTITY],
  })
  quantity: number;

  @ApiProperty({
    description:
      'Optional parameter to force the price of the operation. If not defined, price will be set automatically, based on NAV value (recommended).',
    example: ActionExample[ActionKeys.PRICE],
  })
  @IsOptional()
  forcePrice: number;

  @ApiProperty({
    description: 'Number of hours before the hold expires',
    example: 24,
  })
  nbHoursBeforeExpiration: number;

  @ApiProperty({
    description: 'Hash of the secret required to execute the hold (32 bytes)',
    example:
      '0xb90d6f467cd8182bbd6344f749303fee92ac8b493c46fe455049702ef5b6976a',
  })
  secretHash: string;

  @ApiProperty({
    description:
      'Object to store any additional data (potentially use case related data)',
    example: InputDataExample,
  })
  @IsOptional()
  data: any;
}

export class HoldHybridTokenOutput {
  @ApiProperty({
    description: 'Action, keeping track of the hold operation',
    example: ActionExample,
  })
  @ValidateNested()
  tokenAction: Action;

  @ApiProperty({
    description:
      "'true' if action has been created, 'false' if it was already created (idempotency)",
    example: true,
  })
  created: boolean;

  @ApiProperty({
    description: 'ID of the transaction envelope/context in off-chain DB',
    example: TransactionExample[TxKeys.ENV_IDENTIFIER_ORCHESTRATE_ID],
  })
  transactionId: string;

  @ApiProperty({
    description: 'Response message',
    example: 'Token hold created successfully',
  })
  message: string;
}

export class ForceHoldHybridTokenParamInput {
  @ApiProperty({
    description: 'ID of token, where a hold transaction shall be executed',
    example: TokenExample[TokenKeys.TOKEN_ID],
  })
  tokenId: string;
}

export class ForceHoldHybridTokenBodyInput {
  @ApiProperty({
    description:
      '[OPTIONAL] Idempotency key (shall be unique and generated on client side), used to ensure object is not created twice',
    example: ActionExample[ActionKeys.IDEMPOTENCY_KEY],
  })
  @IsOptional()
  idempotencyKey: string;

  @ApiProperty({
    description: 'ID of the user, whom tokens shall be put on hold',
    example: UserExample[UserKeys.USER_ID],
  })
  investorId: string;

  @ApiProperty({
    description: 'ID of the user, who shall be added as recipient of the hold',
    example: UserExample[UserKeys.USER_ID],
  })
  recipientId: string;

  @ApiProperty({
    description: `State of the token to hold, chosen amongst ${getEnumValues(
      TokenState,
    )}`,
    example: TokenState.LOCKED,
  })
  state: TokenState;

  @ApiProperty({
    description: 'Class of the tokens to hold',
    example: ActionExample[ActionKeys.ASSET_CLASS],
  })
  class: string;

  @ApiProperty({
    description: 'Quantity of tokens to hold',
    example: ActionExample[ActionKeys.QUANTITY],
  })
  quantity: number;

  @ApiProperty({
    description:
      'Optional parameter to force the price of the operation. If not defined, price will be set automatically, based on NAV value (recommended).',
    example: ActionExample[ActionKeys.PRICE],
  })
  @IsOptional()
  forcePrice: number;

  @ApiProperty({
    description: 'Number of hours before the hold expires',
    example: 24,
  })
  nbHoursBeforeExpiration: number;

  @ApiProperty({
    description: 'Hash of the secret required to execute the hold (32 bytes)',
    example:
      '0xb90d6f467cd8182bbd6344f749303fee92ac8b493c46fe455049702ef5b6976a',
  })
  secretHash: string;

  @ApiProperty({
    description:
      'Object to store any additional data (potentially use case related data)',
    example: InputDataExample,
  })
  @IsOptional()
  data: any;
}

export class ForceHoldHybridTokenOutput {
  @ApiProperty({
    description: 'Action, keeping track of the hold operation',
    example: ActionExample,
  })
  @ValidateNested()
  tokenAction: Action;

  @ApiProperty({
    description:
      "'true' if action has been created, 'false' if it was already created (idempotency)",
    example: true,
  })
  created: boolean;

  @ApiProperty({
    description: 'ID of the transaction envelope/context in off-chain DB',
    example: TransactionExample[TxKeys.ENV_IDENTIFIER_ORCHESTRATE_ID],
  })
  transactionId: string;

  @ApiProperty({
    description: 'Response message',
    example: 'Token hold created successfully',
  })
  message: string;
}

export class ExecuteHoldHybridTokenParamInput {
  @ApiProperty({
    description: 'ID of token, where a hold shall be executed',
    example: TokenExample[TokenKeys.TOKEN_ID],
  })
  tokenId: string;
}

export class ExecuteHoldHybridTokenBodyInput {
  @ApiProperty({
    description:
      '[OPTIONAL] Idempotency key (shall be unique and generated on client side), used to ensure object is not created twice',
    example: ActionExample[ActionKeys.IDEMPOTENCY_KEY],
  })
  @IsOptional()
  idempotencyKey: string;

  @ApiProperty({
    description: 'ID of hold that shall be executed',
    example:
      '0xdee57eec5fa3e15df2c65a1600b5b5fad62700d6696996d31a3da528549e265b',
  })
  @IsOptional()
  holdId: string;

  @ApiProperty({
    description: 'Secret required to execute the hold (32 bytes)',
    example:
      '0xdee57eec5fa3e15df2c65a1600b5b5fad62700d6696996d31a3da528549e265b',
  })
  htlcSecret: string;

  @ApiProperty({
    description:
      'Optional parameter to force the price of the operation. If not defined, price will be set automatically, based on NAV value (recommended).',
    example: ActionExample[ActionKeys.PRICE],
  })
  @IsOptional()
  forcePrice: number;

  @ApiProperty({
    description:
      'Object to store any additional data (potentially use case related data)',
    example: InputDataExample,
  })
  @IsOptional()
  data: any;
}

export class ExecuteHoldHybridTokenOutput {
  @ApiProperty({
    description: 'Action, keeping track of the hold operation',
    example: ActionExample,
  })
  @ValidateNested()
  tokenAction: Action;

  @ApiProperty({
    description:
      "'true' if action has been created, 'false' if it was already created (idempotency)",
    example: true,
  })
  created: boolean;

  @ApiProperty({
    description: 'ID of the transaction envelope/context in off-chain DB',
    example: TransactionExample[TxKeys.ENV_IDENTIFIER_ORCHESTRATE_ID],
  })
  transactionId: string;

  @ApiProperty({
    description: 'Response message',
    example: 'Token hold created successfully',
  })
  message: string;
}

export class ReleaseHoldHybridTokenParamInput {
  @ApiProperty({
    description: 'ID of token, where a hold shall be released',
    example: TokenExample[TokenKeys.TOKEN_ID],
  })
  tokenId: string;
}

export class ReleaseHoldHybridTokenBodyInput {
  @ApiProperty({
    description:
      '[OPTIONAL] Idempotency key (shall be unique and generated on client side), used to ensure object is not created twice',
    example: ActionExample[ActionKeys.IDEMPOTENCY_KEY],
  })
  @IsOptional()
  idempotencyKey: string;

  @ApiProperty({
    description: 'ID of hold that shall be released',
    example:
      '0xdee57eec5fa3e15df2c65a1600b5b5fad62700d6696996d31a3da528549e265b',
  })
  @IsOptional()
  holdId: string;

  @ApiProperty({
    description:
      'Object to store any additional data (potentially use case related data)',
    example: InputDataExample,
  })
  @IsOptional()
  data: any;
}

export class ReleaseHoldHybridTokenOutput {
  @ApiProperty({
    description: 'Action, keeping track of the hold operation',
    example: ActionExample,
  })
  @ValidateNested()
  tokenAction: Action;

  @ApiProperty({
    description:
      "'true' if action has been created, 'false' if it was already created (idempotency)",
    example: true,
  })
  created: boolean;

  @ApiProperty({
    description: 'ID of the transaction envelope/context in off-chain DB',
    example: TransactionExample[TxKeys.ENV_IDENTIFIER_ORCHESTRATE_ID],
  })
  transactionId: string;

  @ApiProperty({
    description: 'Response message',
    example: 'Token hold created successfully',
  })
  message: string;
}
